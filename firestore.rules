/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most data, with public read access to certain collections.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the owner.
 * - /users/{userId}/notifications/{notificationId}: Notifications for a user, accessible only to the owner.
 * - /teams/{teamId}: Teams within the organization, publicly readable, writeable by anyone for prototyping purposes.
 * - /contacts/{contactId}: Contacts (clients, suppliers, partners), publicly readable, writeable by anyone for prototyping purposes.
 * - /projects/{projectId}: Projects, publicly readable, writeable by anyone for prototyping purposes.
 * - /projects/{projectId}/stages/{stageId}: Stages within projects, publicly readable, writeable by anyone for prototyping purposes.
 * - /projects/{projectId}/tasks/{taskId}: Tasks within stages, publicly readable, writeable by anyone for prototyping purposes.
 * - /projects/{projectId}/files/{fileId}: Files associated with projects, publicly readable, writeable by anyone for prototyping purposes.
 * - /chats/{chatId}: Chat metadata, access controlled via userIds array.
 * - /chats/{chatId}/messages/{messageId}: Chat messages, access controlled via parent chat document.
 * - /products/{productId}: Products, publicly readable, writeable by anyone for prototyping purposes.
 * - /seals/{sealId}: Seals, publicly readable, writeable by anyone for prototyping purposes.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 * - Read-only collections are explicitly marked as such.
 *
 * Denormalization for Authorization:
 * - Chats include a `userIds` array to efficiently determine access for participants.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Controls access to user profiles. Only the user themselves can read/write their profile.
     * @path /users/{userId}
     * @allow (create, update, delete, get, list) if the user is the owner.
     * @deny (create, update, delete) if the user is not the owner.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to notifications for a specific user. Only the user themselves can read/write their notifications.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create, update, delete, get, list) if the user is the owner.
     * @deny (create, update, delete) if the user is not the owner.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

      /**
       * @description Controls access to teams.
       * @path /teams/{teamId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /teams/{teamId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

      /**
       * @description Controls access to contacts.
       * @path /contacts/{contactId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /contacts/{contactId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

      /**
       * @description Controls access to projects.
       * @path /projects/{projectId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /projects/{projectId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

      /**
       * @description Controls access to stages within projects.
       * @path /projects/{projectId}/stages/{stageId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /projects/{projectId}/stages/{stageId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

      /**
       * @description Controls access to tasks within projects.
       * @path /projects/{projectId}/tasks/{taskId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /projects/{projectId}/tasks/{taskId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

      /**
       * @description Controls access to files within projects.
       * @path /projects/{projectId}/files/{fileId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /projects/{projectId}/files/{fileId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

    /**
     * @description Controls access to chat metadata.  Users must be a participant in the chat.
     * @path /chats/{chatId}
     */
    match /chats/{chatId} {
      allow get: if isSignedIn() && request.auth.uid in resource.data.userIds;
      allow list: if false; // Listing chats not allowed in this prototype.
      allow create: if isSignedIn() && request.resource.data.userIds.hasAll([request.auth.uid]);
      allow update: if isSignedIn() && request.auth.uid in resource.data.userIds && resource != null;
      allow delete: if isSignedIn() && request.auth.uid in resource.data.userIds && resource != null;
    }

    /**
     * @description Controls access to messages within a chat. Users must be a participant in the parent chat.
     * @path /chats/{chatId}/messages/{messageId}
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userIds.hasAny([request.auth.uid]);
      allow list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userIds.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userIds.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userIds.hasAny([request.auth.uid]) && resource != null;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userIds.hasAny([request.auth.uid]) && resource != null;
    }

      /**
       * @description Controls access to products.
       * @path /products/{productId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /products/{productId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

      /**
       * @description Controls access to seals.
       * @path /seals/{sealId}
       * @allow (get, list) to everyone.
       * @allow (create, update, delete) to anyone - prototyping purposes
       * @principle Publicly readable, writeable by anyone.
       */
      match /seals/{sealId} {
        allow get, list: if true;
        allow create, update, delete: if true;
      }

     /**
      * @description This path should NOT exist.  The error indicates that the client is trying to write to a collection called `/roles`.
      * @path /roles
      */
     match /roles {
        allow get, list: if false;
        allow create, update, delete: if false;
     }
  }
}