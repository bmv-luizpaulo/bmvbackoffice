rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Root-level access check to ensure that the database matches the default.
     */
    match /{document=**} {
        allow read, write: if false;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(ownerId) {
      return isSignedIn() && resource.data.ownerId == ownerId;
    }

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their own document.
     *   - request.auth.uid: 'user123'
     *   - resource.data.id: 'user123'
     * @allow (get, update, delete) User with ID 'user123' can access their document.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a document for user 'user123'.
     *   - request.auth.uid: 'user456'
     *   - resource.data.id: 'user123'
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Prevent listing all users

      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId) && request.auth.uid == userId;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/notifications/{notificationId} collection.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create) User with ID 'user123' can create a notification in their own collection.
     *   - request.auth.uid: 'user123'
     * @allow (get, update, delete) User with ID 'user123' can access notifications in their own collection.
     *   - request.auth.uid: 'user123'
     * @deny (list) Non-owner cannot list the notifications.
     *   - request.auth.uid: 'user456'
     * @deny (create) User with ID 'user456' cannot create a notification in user 'user123's collection.
     *   - request.auth.uid: 'user456'
     * @principle Restricts access to a user's own notifications.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Rules for the /teams/{teamId} collection.
     * @path /teams/{teamId}
     * @allow (get, list) Public read access to all teams.
     * @allow (create) Owner with correct ownerId can create
     * @allow (update, delete) Owner with correct ownerId can update and delete.
     * @principle Public read, owner-only writes.
     */
    match /teams/{teamId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;
    }

   /**
     * @description Rules for the /roles/{roleId} collection.
     * @path /roles/{roleId}
     * @allow (get, list) Public read access to all roles.
     * @allow (create, update, delete) No write access.
     * @principle Completely public collection for roles
     */
    match /roles/{roleId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /contacts/{contactId} collection.
     * @path /contacts/{contactId}
     * @allow (get, list) Public read access to all contacts.
     * @allow (create, update, delete) Only the owner can modify contacts.
     * @principle Public read, owner-only writes.
     */
    match /contacts/{contactId} {
      allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /projects/{projectId} collection.
     * @path /projects/{projectId}
     * @allow (get, list) Public read access to all projects.
     * @allow (create) Only the owner can create projects, validating ownerId.
     * @allow (update, delete) Only the owner can update and delete projects.
     * @principle Public read, owner-only writes.
     */
    match /projects/{projectId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /projects/{projectId}/stages/{stageId} collection.
     * @path /projects/{projectId}/stages/{stageId}
     * @allow (get, list) Public read access to all stages.
     * @allow (create, update, delete) Only project owner can write stages.
     * @principle Public read, owner-only writes, inherited from parent.
     */
    match /projects/{projectId}/stages/{stageId} {
      allow get, list: if true;
        allow create: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /projects/{projectId}/tasks/{taskId} collection.
     * @path /projects/{projectId}/tasks/{taskId}
     * @allow (get, list) Public read access to all tasks.
     * @allow (create, update, delete) Only project owner can write tasks.
     * @principle Public read, owner-only writes, inherited from parent.
     */
    match /projects/{projectId}/tasks/{taskId} {
      allow get, list: if true;
        allow create: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /projects/{projectId}/files/{fileId} collection.
     * @path /projects/{projectId}/files/{fileId}
     * @allow (get, list) Public read access to project files.
     * @allow (create, update, delete) Only project owner can manage files.
     * @principle Public read, owner-only writes, inherited from parent.
     */
    match /projects/{projectId}/files/{fileId} {
      allow get, list: if true;
        allow create: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /chats/{chatId} collection.
     * @path /chats/{chatId}
     * @allow (get, list) Any participant can read the chat metadata.
     * @allow (create) Any participant can create a chat.
     * @allow (update) Only participants can update chat metadata
     * @allow (delete) No one can delete a chat via client.
     * @principle Shared access: only chat participants can read/write.
     */
    match /chats/{chatId} {
        function isParticipant() {
            return request.auth.uid in request.resource.data.userIds;
        }

        allow get, list: if isSignedIn() && request.resource.data.userIds.hasAny([request.auth.uid]);
        allow create: if isSignedIn() && request.resource.data.userIds.hasAny([request.auth.uid]);
        allow update: if isSignedIn() && request.resource.data.userIds.hasAny([request.auth.uid]);
        allow delete: if false;
    }

    /**
     * @description Rules for the /chats/{chatId}/messages/{messageId} collection.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) Only chat participants can read messages.
     * @allow (create) Only chat participants can send messages.
     * @allow (update, delete) No one can update or delete messages via client.
     * @principle Shared access: only chat participants can read/write messages.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userIds.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.userIds.hasAny([request.auth.uid]);
      allow update, delete: if false;
    }

    /**
     * @description Rules for the /products/{productId} collection.
     * @path /products/{productId}
     * @allow (get, list) Public read access to all products.
     * @allow (create, update, delete) Only the owner can modify products.
     * @principle Public read, owner-only writes.
     */
    match /products/{productId} {
      allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /seals/{sealId} collection.
     * @path /seals/{sealId}
     * @allow (get, list) Public read access to all seals.
     * @allow (create, update, delete) Only the owner can modify seals.
     * @principle Public read, owner-only writes.
     */
    match /seals/{sealId} {
      allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /checklists/{checklistId} collection.
     * @path /checklists/{checklistId}
     * @allow (get, list) Public read access to all checklists.
     * @allow (create, update, delete) Only the team owner can modify checklists.
     */
    match /checklists/{checklistId} {
      allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Rules for the /checklists/{checklistId}/items/{itemId} collection.
     * @path /checklists/{checklistId}/items/{itemId}
     * @allow (get, list) Public read access to checklist items.
     * @allow (create, update, delete) Only the team owner can modify checklist items.
     */
    match /checklists/{checklistId}/items/{itemId} {
      allow get, list: if true;
        allow create: if isSignedIn() && get(/databases/$(database)/documents/checklists/$(checklistId)).data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/checklists/$(checklistId)).data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/checklists/$(checklistId)).data.ownerId == request.auth.uid;
    }
  }
}